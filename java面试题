1.spring如何尝试解决循环引用的问题
(1)创建对象A的时候，【先提前暴露一个已实例化未初始化的beanA】，下面填充属性的时候，要依赖对象B创建对象B，对象B又依赖对象A,这时候可以直接拿之前提前暴露的未初始化的beanA，这样相互依赖的对象A、B都可以初始化了

(2)解决循环依赖的原理实际上是java是基础对象引用的传递，我们可以先依赖对象的引用，对象的属性可以稍后加载

(3)能解决基于属性之间的依赖，解决不了构造函数依赖

2.spring的ioc过程
1、加载bean的定义
2、定义加载完毕后，触发bean定义的后置处理器
3、创建bean对象
4、bean全部创建完成后的事件通知

3.AopContext.currentProxy()从当前线程的threadLocal中获取当前的代理对象

4.java枚举是什么？里面可以写抽象方法么？类可以被继承么

5.AQS内部实现 synchronized优化（偏向锁、轻量级锁(自旋锁)、重量级锁）

-公平锁和非公平锁区别

-显示锁和synchronized区别

6.阻塞队列（LinkedBlockingQueue SynchronousQueue） 线程池(工作原理 shutdown和shutdownNow区别)

7.闭锁和栅栏干嘛的？有什么区别？

8.dubbo框架 mq 

9.sql性能优化 mysql索引分类 事务

10.选一个你认为比较得意的项目？有什么难点？如何解决的？

11.java类加载机制
(1)加载
加载类的全限定名称，生成二进制字节流
生成class对象放在方法区里，作为访问类的数据结构的入口

(2)验证
验证数据描述类型、语义

(3)准备
为一些类的变量（静态变量）分配内存

(4)解析
虚拟机将常量池内的符号引用替换为直接引用的过程

(5)初始化
初始化类的静态变量以及执行静态代码块

触发条件：
-创建类的实例
-访问类的静态变量和静态方法
-反射

12.类加载器-双亲委派模型

13.mysql事务四大特性+四大隔离级别

四大特性：
A(原子性) C（一致性） I（隔离性） D（持久性）

四大隔离级别：
(1)Read uncommitted
一个事务能读到另外一个事务未提交的数据，从而产生【脏读】

(2)read committed
一个事务要等到另外的事务提交事务后才能读数据，但是这可能产生一次事务范围中两次相同的查询返回不同结果，造成一个【不可重复读的问题】

(3)repeatable read【mysql默认事务级别】
一个事务开启时，不允许其他事务的修改。但是这时候允许其他事务的一个插入动作，造成【幻读】

(4)Serializable  事务串行执行 不允许并发

14.spring事务级别

15.dubbo请求应答怎么对应上的?dubbo负载均衡策略？dubbo的客户端重试机制？

16.线程池？闭锁？future等待通知机制



Java中object常用方法
1、clone() 
2、equals() 
3、finalize() 
4、getclass() 
5、hashcode() 
6、notify() 
7、notifyAll() 
8、toString()

Java序列化与反序列化是什么？为什么需要序列化与反序列化？如何实现Java序列化与反序列化？

Arrays和Collections 对于sort的不同实现原理？

Spring AOP 实现原理？

抽象类和接口的联系?
#相同点
(1）他们都不能被实例化，只是用于其他类继承和实现的
(2) 他们都包含有抽象方法，继承和实现他们的类都需要实现这些抽象方法
#不同点
(1)接口里只能包含抽象方法，而抽象类里还可以写普通方法
(2)接口里只能定义静态变量，而抽象类里可以定义普通变量、静态变量用于继承


 再问你一下设计模式相关的吧，请你介绍一下观察者模式？或者举个观察者模式的例子吧。

 Java中的NIO，BIO，AIO分别是什么
