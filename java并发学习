1.volatile
(1)直接将线程本地缓存中所有的共享变量(注意不仅仅包括volatile修饰的共享变量，
还包括普通的共享变量)写回到主内存中
(2)让其他线程本地缓存失效
(3)volatile只保证线程的可见性 不保证线程的原子性（保证原子性需配套用自旋cas）
-可见性：对volatile变量的写，对于他后续的读立马可见
-原子性：对任意单个volatile变量的读写保证原子性，但是不保证类似++的复合操作 的原子性

2.锁类型
(1)偏向锁（可重入锁）
-大多数情况下，锁不仅没有多线程竞争，而且总是由一个线程多次获取，为了让获取锁的代价更低引入的偏向锁。
-当以后线程再次进入退出同步块的时候不需要进行cas操作来加锁解锁，只是看下对象头里偏向锁持有的线程是不是当前线程
-锁有竞争时，撤销偏向锁
-偏向锁适合只有一个线程访问的同步块

(2)轻量级锁(自旋锁)
-cas获取修改对象头的锁状态为，成功表示获取到锁了，失败尝试自旋来不停获取锁(要不停销毁cpu，但是避免了线程阻塞带来的上下文切换)
-cas释放锁时，若失败表示同步快有竞争，则锁升级为重量级锁
-轻量级锁适合于同步快执行非常快，多线程基本没有竞争的场景（SynchronousQueue,dubbo的io线程池）

(3)重量级锁
-当锁处于重量级锁状态时，线程竞争比较激烈，其他未获取到锁的线程直接阻塞，当持有锁的线程释放锁时才通知到这些阻塞中的线程，被唤醒的线程会新一轮的竞争锁。
-适用于同步块执行时间长的场景



3.java原子操作原理
自旋cas

4.java内存模型(JMM)
--基于共享内存的方式
--happens-before
--重排序
--顺序一致性

5.happens before原则：
(1) 对volatile变量的写 happens before于后续对它的读
(2) 对一个锁的解锁 happens before 于后续对这个锁的加锁

6.final内存语义

7.多线程
(1) 线程6状态
开始：线程start之前
就绪：线程start之后，还没有cpu调度
运行：有cpu调度，线程开始运行
等待：线程因条件不满足，线程挂起，释放cpu
超时等待：线程因条件不满足，线程超时挂起，释放cpu
阻塞：
终止：线程执行完毕

(2) sleep() wait() yield() join()用法与区别
sleep:线程进入超时等待状态，不释放锁
wait:线程进入等待状态，释放锁
yield:让线程从运行状态到就绪状态，让其他线程先执行，当然当前线程也有机会调度执行
join: 主线程等待子线程执行完毕

(3) 等待通知机制，生产者消费者模式


8.ThreadLocal
线程绑定
弱引用


9.锁
(1)lock和synchronized区别

(2)队列同步器AbstractQueuedSynchronizer（AQS）
--acquire  不响应中断的竞争获取独占锁
--acquireInterruptibly 响应中断地竞争独占锁
--tryAcquireNanos 超时竞争获取独占锁

--acquireShared  不响应中断的竞争获取共享锁
--acquireSharedInterruptibly 响应中断地竞争共享锁
--tryAcquireSharedNanos 超时竞争获取共享锁

(3)锁降级（写锁退化成读锁 读锁升级成写锁不允许）

(4)公平非公平锁
  -公平锁(获取锁遵循绝对的fifo时间顺序原则排队):当能获取锁时判断同步队列中
是否有节点，表示有线程比当前线程更早获取锁的，此时当前线程应该获取锁失败加入到同步队列中取排队;
  -非公平锁(允许插队):当前线程能获取锁时，不管同步队列中是否有更早等待获取
锁的线程;
  -非公平锁比公平锁吞吐量高的原因：公平锁依靠同步队列排队，释放锁时不停的唤醒挂起的头节点的后继，线程上下文的切换比较多，会消耗CPU资源.当持有锁的时间相对较长或者请求锁的平均时间间隔较长，应该使用公平锁。在这些情况下，插队带来的吞吐量提升（当锁处于可用状态时，线程却还处于被唤醒的过程中）可能不会出现。




10.condition
(1)等待通知机制

(2)生产者消费者模式

(3)condition与object.wait()区别


11.阻塞队列
(1)LinkedBlockingQueu
-two-lock-queue
-putLock
-takeLock

(2)SynchronousQueue
duals lock
-lock-free(无锁技术)
-通过spin自旋限制竞争

offer和poll操作：若此时队列中没有可以匹配的线程,不会等待，则直接返回null

take和put操作：若此时队列中没有可匹配的线程节点，则会先自旋一段时间然后进入等待直到被后续的线程匹配上唤醒

使用场景：
* SynchronousQueue每一个生产者线程都需要等待另一个线程的消费者线程，生产者生产能力和消费者消费能力对等，queue不会因为生产者线程过多，而导致系统崩溃，若没有足够的消费能力，则生产者直接返回null（offer），不消费，保证最新的生产请求不会因为之前任务过多导致没有线程消费.
* 适用于生产消费能力差不多，线程执行任务足够快，通过自旋等待后续匹配的线程，减少了线程上下文切换，比其他阻塞队列加锁来的吞吐量高


(3)LinkedBlockingQueue和SynchronousQueue区别

(4)DelayQueue
  -leader-follower模式：
   leader线程等待队列head节点元素过期，其他follower线程无限期等待


13.JUC 3大并发工具CountDownLatch、CyclicBarrier和Semaphore
CountDownLatch：让一个线程或者一组线程，等待其他线程执行结束，才开始工作

CyclicBarrier：设置一个屏障，让一组线程到达这个屏障时阻塞，直到所有线程到达屏障时，才放开，让所有线程同时开始工作

Semaphore：控制并发访问的个数

 
14.线程池：
(1)一个工作者线程何时创建？开启运行的时候做些什么事？

创建核心线程：
-核心线程池预热,调用prestartAllCoreThreads方法
-当客户端提交任务时，若此时的线程池中的工作者线程数小于核心线程数，则创建核心线程
-通过调用线程池提供的setCorePoolSize接口，若新的核心线程数较大时，会创建核心线程

创建最大(临时)线程：
-当客户端提交任务，任务队列满时，若线程池中线程数小于最大线程数时，则创建最大线程
-当工作者线程退出时，若此时线程数小于核心线程数，则创建最大线程

工作者线程运行时做些什么事：
-不停的从阻塞队列中获取任务，执行run方法
-一个任务执行完毕后，要统计该工作者线程的任务执行数

(2)一个工作者线程何时空闲？当空闲时候，做什么事?

工作者线程何时空闲：


当空闲时候，做什么事:


(3)一个线程池中工作者线程何时退出？退出时要做些什么事？
-将工作者线程执行完的任务数写回线程池中
-从线程池工作者列表中删除该工作者
-尝试终结线程池
-当线程池状态<STOP时，判断若当前工作者线程数小于核心线程数时，则重新开启一个新线程


(4)线程池的一些统计参数
-completedTaskCount 完成的最大任务数
-largestPoolSize    到达的最大线程数

(5)jdk1.6和1.7在线程池实现上的不同

研究线程池时，可以参照dubbo的AbortPolicyWithReport了解一些线程池运行的必要参数
线程池的应用场景
线程池原理
cache线程池
fixed线程池
schedule线程池
不同线程池对比